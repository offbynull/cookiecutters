name: run-tests
on:
  push:
    branches: [main]
  pull_request:
  workflow_dispatch:
jobs:
  # Define meson build types
  # ------------------------
  # Each job further below this one builds and runs on a specific operating system / architecture. To ensure nothing wonky happens with C++
  # optimizations, each of those jobs should be run multiple times, once for each meson build profile (e.g., release, debug, minSize,
  # etc..). Given that GitHub Actions doesn't let you set a "matrix strategy" across all jobs (it only allows it per job), the "matrix
  # strategy" is defined once here as its own job and re-used in other jobs further down from it (source:
  # https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/run-job-variations#using-an-output-to-define-two-matrices)
  define-build-type-matrix:
    runs-on: ubuntu-latest
    outputs:
      build-types: {{ "${{ steps.define-build-types.outputs.build-types }}" }}
    steps:
      - name: Define build types
        id: define-build-types
        run: |
          echo 'build-types=["debug", "release"]' >> "$GITHUB_OUTPUT"
  test-linux:
    runs-on: ubuntu-latest
    needs: define-build-type-matrix
    strategy:
      matrix:
        build-type: {{ "${{ fromJSON(needs.define-build-type-matrix.outputs.build-types) }}" }}
    steps:
      - name: Setup
        uses: ./.github/workflows/setup-linux.yml
      - name: Run unittests
        run: |
          # Compile and run.
          meson setup --reconfigure buildDir {{ "--buildtype=${{ matrix.build-type }}" }}
          meson test -C buildDir -v gtest
  test-windows:
    runs-on: windows-latest
    needs: define-build-type-matrix
    strategy:
      matrix:
        build-type: {{ "${{ fromJSON(needs.define-build-type-matrix.outputs.build-types) }}" }}
    steps:
      - name: Setup
        uses: ./.github/workflows/setup-windows.yml
      - name: Run unittests
        shell: powershell
        run: |
          # Compile and run.
          ./msys.bat "meson setup --reconfigure buildDir {{ "--buildtype=${{ matrix.build-type }}" }}""
          ./msys.bat "meson test -C buildDir -v gtest"
  test-mac:
    runs-on: macos-latest
    needs: define-build-type-matrix
    strategy:
      matrix:
        build-type: {{ "${{ fromJSON(needs.define-build-type-matrix.outputs.build-types) }}" }}
    steps:
      - name: Setup
        uses: ./.github/workflows/setup-macos.yml
      - name: Run unittests
        run: |
          # Ensure meson finds boost (that was compiled above).
          export BOOST_ROOT="$HOME/boost-gcc"
          export CPATH="$BOOST_ROOT/include:${CPATH:-}"
          export LIBRARY_PATH="$BOOST_ROOT/lib:${LIBRARY_PATH:-}"
          export DYLD_LIBRARY_PATH="$BOOST_ROOT/lib:${DYLD_LIBRARY_PATH:-}"
          # Ensure meson uses gcc/g++.
          export CC="$BREW_BIN/gcc-$GCC_VER"
          export CXX="$BREW_BIN/g++-$GCC_VER"
          # Ensure gcc's version of binary utilities are used.
          #
          # NOTE: According to o3, AR and RANLIB are not required because we're not building a static library (this is an executable). LD
          #       also isn't required because meson links via the compiler? This doesn't seem to be entierly true. g++ points meson to
          #       Apple's clang linker if LD isn't set?
          export AR="$BREW_BIN/gcc-ar-$GCC_VER"
          export RANLIB="$BREW_BIN/gcc-ranlib-$GCC_VER"
          export LD="$BREW_BIN/g++-$GCC_VER"
          # Compile and run.
          meson setup --reconfigure buildDir {{ "--buildtype=${{ matrix.build-type }}" }}
          meson test -C buildDir -v gtest