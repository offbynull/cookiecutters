# By default, Windows runners come preloaded with Apple's variant of clang as a compiler. To reduce variability from different C++
# compilers supporting different compiling features, different language features, and having different compilation idiosyncrasies/bugs,
# everything is explicitly targeting GCC for compiling and linking.
name: setup-macos
runs:
  using: composite
  steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      - name: Install deps
        run: |
          brew update
          # Install g++ and gcc.
          brew install gcc
          # Expose version of g++/gcc installed.
          BREW_BIN="$(brew --prefix)/bin"
          GCC_VER="$(ls "$BREW_BIN"/gcc-[0-9]* | sed -E 's|.*/gcc-([0-9]+).*|\1|' | sort -V | tail -1)"
          echo "BREW_BIN=$BREW_BIN" >> "$GITHUB_ENV"
          echo "GCC_VER=$GCC_VER" >> "$GITHUB_ENV"
          # Install meson and deps required by meson.
          brew install pkg-config
          python -m pip install --upgrade pip
          python -m pip install meson ninja
          {% if cookiecutter.include_python_extension != 'false' -%}
          # Install python requirements.
          python -m pip install build  # Required for building python extension
          {%- endif %}
          {% if cookiecutter.include_python_extension == 'true_with_numpy' -%}
          python -m pip install numpy
          {%- endif %}
          {% if cookiecutter.min_boost_version != 'na' -%}
          # DO NOT INSTALL BOOST HERE - Boost installed in subsequent steps
          {%- endif %}
          {% if cookiecutter.include_doxygen -%}
          # Install doxygen.
          brew install graphviz doxygen    # Required for building docs
          {%- endif %}
      {% if cookiecutter.min_boost_version != 'na' -%}
      # NOTE: At time of writing, boost is taking about 10 minutes to build on macos-latest runner. To reduce build time, the caching
      #       mechanism provided by GitHub Actions is used.
      #
      # WARNING: DO NOT INSTALL BOOST BY INSERTING "brew install boost" above -- it'll install boost compiled against clang instead of g++,
      #          which is not compatible (libc++ vs libstdc++).
      - name: Cache Boost
        id: boost-cache
        uses: actions/cache@v4
        with:
          path: ~/boost-gcc
          key: {{ "boost-1.87.0-gcc${{ env.GCC_VER }}-${{ runner.os }}-${{ runner.arch }}" }}
      - name: Build Boost if cache miss
        if: steps.boost-cache.outputs.cache-hit != 'true'
        run: |
          # Download boost.
          BOOST_VER=1.87.0
          curl -L "https://archives.boost.io/release/${BOOST_VER}/source/boost_${BOOST_VER//./_}.tar.bz2" | tar -xj -C "$RUNNER_TEMP"
          cd "$RUNNER_TEMP"/boost_*
          # Prime boost to compile on gcc/g++.
          export CC="$BREW_BIN/gcc-$GCC_VER"
          export CXX="$BREW_BIN/g++-$GCC_VER"
          ./bootstrap.sh --with-toolset=gcc --prefix="$HOME/boost-gcc"
          # Build boost.
          #
          # NOTE: The arguments used below have the following meaning...
          #
          #        * -j"$(sysctl -n hw.logicalcpu)" utilizes all cores, to keep the build fast.
          #        * -variant=release builds a release version of boost (as opposed to a debug version).
          #          (see https://stackoverflow.com/q/73237306)
          #        * -threading-multi builds a thread-aware version of boost. Note that thread-aware does not mean thread-safe: Thread-safe
          #          means that access to the same object from multiple threads is safe, while thread-aware means that boost objects work
          #          fine when used solely within a single thread of a multithreaded application.
          #          (https://stackoverflow.com/a/20991533)
          #
          # NOTE: o3 used arguments, but I've removed them because either boost's buildsystem already does this, or they're not required,
          #       or they might end up breaking things.
          #
          #        * -cxxflags="-march=native -flto -pipe" -linkflags="-march=native -flto"
          #          * is machine architecture implicitly set to native already?
          #          * no need for link-time optimizations. If it's not being enabled implicitly by boost's build system, I'd rather not
          #            enable it. Even if everything turns out fine, the extra build timecost of enabling it may not be worth the marginal benefits.
          #          * leave whether to use pipe vs temp files to boost's build system.
          ./b2 \
              -j"$(sysctl -n hw.logicalcpu)" \
              variant=release link=static,shared threading=multi \
              install
      {%- endif %}