# NOTE: If you change something in this workflow (e.g., bug fix, workaround, optimization, ...), make sure the cookiecutter is updated as
#       well.
name: setup-windows-msys2-gcc-ucrt
inputs:
  python-version:
    description: "Python version"
    required: true
    default: "PYTHON_VERSION_NOT_SET"  # Setting required=true seems to do nothing, so set a bad default to make things not work (not
                                       # setting a default will cause the default to be an empty string - workflow will pass with empty
                                       # string, but it won't be right).
runs:
  using: composite
  steps:
    - name: Install msys2
      shell: pwsh
      run: |
        # Force non-zero exit codes to stop task (similar to how linux/mac runners work).
        $PSNativeCommandUseErrorActionPreference = $true
        $ErrorActionPreference = 'Stop'
        # Install msys2
        choco install msys2 -y
        # Create shell to launch msys commands.
        #
        # NOTE: You can't just do echo "..." > msys2.ps1. It adds a byte-order marker (BOM) to msys2.ps1, which ultimately causes an error
        #       when you try to run it. What's below is a workaround recommended by a LLM.
        @'
        param(
          [Parameter(ValueFromRemainingArguments=$true)]
          [string[]]$Cmd
        )
        $Cmd = [string]::Join(' ', $Cmd)

        # echo ('Launching ' + $Cmd.Trim())

        & 'C:\tools\msys64\usr\bin\env.exe' `
          'MSYSTEM=UCRT64' 'CHERE_INVOKING=1' `
          '/usr/bin/bash' '-lc' $Cmd

        exit $LASTEXITCODE
        '@ | Out-File .\msys2.ps1 -Encoding ascii
        # Update deps
        #
        # NOTE: Command below is explicitly being run twice. Apparently you need two passes for it to actually update?
        .\msys2.ps1 'pacman -Syyu --noconfirm'
        .\msys2.ps1 'pacman -Syyu --noconfirm'
    - name: Install deps
      shell: pwsh
      run: |
        # Force non-zero exit codes to stop task (similar to how linux/mac runners work).
        $PSNativeCommandUseErrorActionPreference = $true
        $ErrorActionPreference = 'Stop'
        # Install packages
        {% if cookiecutter.include_python_extension != 'false' -%}
        #
        # NOTE: To build python extensions on this platform, meson-python must explicitly be installed via pacman. This doesn't seem to be
        #       the case for mac, linux, and windows (not windows running msys2, but normal windows) - these platforms all seem to
        #       implicitly install meson-python when "python -m build --wheel" runs (or is it installed as a transitive dependency?).
        {%- endif %}
        {% if cookiecutter.include_python_extension == 'true_with_numpy' -%}
        #
        # WARNING: Notice that numpy is being pulled in via pacman instead of "pip install numpy". The pacman version includes prebuilt
        #          numpy binaries where as "pip install numpy" will attempt to build those binaries from scratch (takes a very long time).
        {%- endif %}
        .\msys2.ps1 'pacman -Sy --noconfirm \
          mingw-w64-ucrt-x86_64-toolchain \
          mingw-w64-ucrt-x86_64-python \
          mingw-w64-ucrt-x86_64-python-pip \
          mingw-w64-ucrt-x86_64-meson \
          mingw-w64-ucrt-x86_64-ninja \
          mingw-w64-ucrt-x86_64-pkg-config \
          {% if cookiecutter.include_python_extension != 'false' -%}
          mingw-w64-ucrt-x86_64-meson-python \
          mingw-w64-ucrt-x86_64-python-build \
          {%- endif %}
          {% if cookiecutter.include_python_extension == 'true_with_numpy' -%}
          mingw-w64-ucrt-x86_64-python-numpy \
          {%- endif %}
          {% if cookiecutter.include_doxygen -%}
          mingw-w64-ucrt-x86_64-doxygen \
          mingw-w64-ucrt-x86_64-graphviz \
          {%- endif %}
          mingw-w64-ucrt-x86_64-curl \
          {% if cookiecutter.boost_version != 'na' -%}
          mingw-w64-ucrt-x86_64-dlfcn \
          mingw-w64-ucrt-x86_64-zlib \
          mingw-w64-ucrt-x86_64-bzip2 \
          mingw-w64-ucrt-x86_64-zstd \
          mingw-w64-ucrt-x86_64-xz \
          mingw-w64-ucrt-x86_64-icu \
          mingw-w64-ucrt-x86_64-openssl
          {%- endif %}
          '
        {% if cookiecutter.include_python_extension != 'false' -%}
        # WARNING: msys2 does rolling release of Python. It doesn't let you target a specific major-minor version of Python and the GitHub
        #          setup-python action doesn't extend into / provide support for msys2's enivornments. Short of compiling python from
        #          source (at the intended major-minor version), the only other thing that can be done is to test if the installed python
        #          matches the expected major-minor. That test is what's happening here. This must be changed at some point to compile
        #          python from source (at intended major-minor version).
        python -c 'import sys; assert "{{ "${{ inputs.python-version }}" }}" == ".".join(map(str, sys.version_info[:2])), f"Bad Python version {sys.version_info}"'
        {%- endif %}
        {% if cookiecutter.boost_version != 'na' -%}
        # Set boost version.
        #
        # WARNING: Do not install pre-built boost binaries via a package manager. Pre-built boost binaries may not be complete unless built
        #          from scratch with certain dependendencies present (e.g., NumPy boost component requires your python installation to have
        #          numpy installed). Instead, set the version of boost to install (installation happens in subsequent steps).
        {% if cookiecutter.include_python_extension == 'true_with_numpy' -%}
        #          
        #          If you want boost's python and numpy components available, you must have installed python (and numpy) prior to building.
        {%- endif %}
        #
        # NOTE: The pacman packages installed above (after curl) are required for building boost.
        $BOOST_VER="{{ cookiecutter.boost_version }}"
        Add-Content $Env:GITHUB_ENV "BOOST_VER=$BOOST_VER"
        {%- endif %}
        # Extract GCC version
        $GCC_VER = (.\msys2.ps1 'gcc -dumpfullversion | xargs').Trim()
        Add-Content $Env:GITHUB_ENV "GCC_VER=$GCC_VER"
    {% if cookiecutter.boost_version != 'na' -%}
    - name: Cache Boost
      id: boost-cache
      uses: actions/cache@v4
      with:
        path: ~/boost-gcc
        key: {{ "boost-${{ env.BOOST_VER }}-msys2-ucrt-gcc${{ env.GCC_VER }}-py${{ inputs.python-version  }}-${{ runner.os }}-${{ runner.arch }}" }}
    - name: Build Boost if cache miss
      if: steps.boost-cache.outputs.cache-hit != 'true'
      shell: pwsh
      run: |
        # Force non-zero exit codes to stop task (similar to how linux/mac runners work).
        $PSNativeCommandUseErrorActionPreference = $true
        $ErrorActionPreference = 'Stop'
        # Download boost and build.
        #
        # NOTE: The arguments used below have the following meaning...
        #
        #        * -j controls how many cores are used to build.
        #        * variant builds boost library in either "debug" mode or "release" mode.
        #        * link builds a boost library as either a "static" library (so or DLL) or "static" library.
        #        * runtime-link builds a boost library against either a "static" CRT or a "static" CRT. This only applies to Windows, where
        #          the CRT type used for boost must match the CRT type of whatever it is pulling it in. On Linux/Mac, it's silently
        #          ignored.
        #        * address-model builds a boost library that's either "32" or "64" bit.
        #        * threading-multi builds a thread-aware version of boost. Note that thread-aware does not mean thread-safe: Thread-safe
        #          means that access to the same object from multiple threads is safe, while thread-aware means that boost objects work
        #          fine when used solely within a single thread of a multithreaded application.
        #          (https://stackoverflow.com/a/20991533)
        #
        #       Because wheels are intended to be self contained, create static library (link=static). To be safe, keep it thread-aware
        #       (threading=multi). Don't bother supporting older 32-bit CPUs (address-model=64).
        #
        # NOTE: $USERPROFILE points to the Windows user's home directory. That is, the path in cache task directly above this one
        #       (~/boost-gcc) and the path in the commands below ($USERPROFILE/boost-gcc) point to the same directory.
        #
        # NOTE: bootstrap.sh gets fed the --prefix path in Windows style rather than Posix style because b2 is a Windows executable and
        #       expects a Windows path. If you pass in a Posix path, it gets translated incorrectly (e.g. /c/Users/runneradmin/boost-gcc
        #       gets rewritten to \c\Users\runneradmin\boost-gcc, which the kernel resolves as C:\c\Users\runneradmin\boost-gcc).
        #
        # WARNING: o3 claims --with-python-root=/ucrt64 because Boost doesn't know where to find Python includes (e.g.,
        #          /ucrt64/include/python3.12). Apparently bootstrap.sh finds /ucrt64/bin/python*, launches it to run the command
        #          "sysconfig.get_python_inc()", and gets the correct include dir back.
        .\msys2.ps1 '
            export BOOST_VER={{ "${{ env.BOOST_VER }}" }} && \
            export BOOST_ROOT=""$(cygpath -u ""$USERPROFILE"")/boost-gcc""
            export BOOST_ROOT_WINDOWS_STYLE=""$(cygpath -m ""$USERPROFILE"")/boost-gcc""
            curl -L ""https://archives.boost.io/release/${BOOST_VER}/source/boost_${BOOST_VER//./_}.tar.bz2"" | tar -xj -C ""/tmp"" && \
            cd /tmp/boost_* && \
            ./bootstrap.sh --with-toolset=gcc --with-python=python3 --with-python-root=/ucrt64 --prefix=$BOOST_ROOT_WINDOWS_STYLE && \
            ./b2 \
              -j""$(nproc)"" \
              variant=release link=static runtime-link=static,shared threading=multi address-model=64 \
              linkflags=""-ldl"" \
              install'
    - name: Prime for building
      shell: pwsh
      run: |
        # Prime env for compiled boost.
        .\msys2.ps1 '
            BOOST_ROOT=""$(cygpath -u ""$USERPROFILE"")/boost-gcc"" && \
            echo ""export BOOST_ROOT=$BOOST_ROOT"" >> ~/.bash_profile && \
            echo ""export CPATH=$BOOST_ROOT/include:${CPATH:-}"" >> ~/.bash_profile && \
            echo ""export LIBRARY_PATH=$BOOST_ROOT/lib:${LIBRARY_PATH:-}"" >> ~/.bash_profile && \
            echo ""export LD_LIBRARY_PATH=$BOOST_ROOT/lib:${LD_LIBRARY_PATH:-}"" >> ~/.bash_profile'
        .\msys2.ps1 'cat ~/.bash_profile'
        .\msys2.ps1 'env'
        .\msys2.ps1 'echo $BOOST_ROOT'
        .\msys2.ps1 'ls -al $BOOST_ROOT'
    {%- endif %}