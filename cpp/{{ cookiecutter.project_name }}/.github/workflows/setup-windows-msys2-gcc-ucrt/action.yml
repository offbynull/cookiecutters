# NOTE: If you change something in this workflow (e.g., bug fix, workaround, optimization, ...), make sure the cookiecutter is updated as
#       well.
name: setup-windows-msys2-gcc-ucrt
runs:
  using: composite
  steps:
    - name: Install msys2
      shell: pwsh
      run: |
        # Force non-zero exit codes to stop task (similar to how linux/mac runners work).
        $PSNativeCommandUseErrorActionPreference = $true
        $ErrorActionPreference = 'Stop'
        # Install msys2
        choco install msys2 -y
        # Create shell to launch msys commands.
        #
        # NOTE: You can't just do echo "..." > msys2.ps1. It adds a byte-order marker (BOM) to msys2.ps1, which ultimately causes an error
        #       when you try to run it. What's below is a workaround recommended by a LLM.
        @'
        param(
          [Parameter(ValueFromRemainingArguments=$true)]
          [string[]]$Cmd
        )
        $Cmd = [string]::Join(' ', $Cmd)

        # echo ('Launching ' + $Cmd.Trim())

        & 'C:\tools\msys64\usr\bin\env.exe' `
          'MSYSTEM=UCRT64' 'CHERE_INVOKING=1' `
          '/usr/bin/bash' '-lc' $Cmd

        exit $LASTEXITCODE
        '@ | Out-File .\msys2.ps1 -Encoding ascii
        # Update deps
        #
        # NOTE: Command below is explicitly being run twice. Apparently you need two passes for it to actually update?
        .\msys2.ps1 'pacman -Syyu --noconfirm'
        .\msys2.ps1 'pacman -Syyu --noconfirm'
    - name: Install deps
      shell: pwsh
      run: |
        # Force non-zero exit codes to stop task (similar to how linux/mac runners work).
        $PSNativeCommandUseErrorActionPreference = $true
        $ErrorActionPreference = 'Stop'
        # Install packages
        {% if cookiecutter.include_python_extension != 'false' -%}
        #
        # NOTE: To build python extensions on this platform, meson-python must explicitly be installed via pacman. This doesn't seem to be
        #       the case for mac, linux, and windows (not windows running msys2, but normal windows) - these platforms all seem to
        #       implicitly install meson-python when "python -m build --wheel" runs (or is it installed as a transitive dependency?).
        {%- endif %}
        {% if cookiecutter.include_python_extension == 'true_with_numpy' -%}
        #
        # WARNING: Notice that numpy is being pulled in via pacman instead of "pip install numpy". The pacman version includes prebuilt
        #          numpy binaries where as "pip install numpy" will attempt to build those binaries from scratch (takes a very long time).
        {%- endif %}
        .\msys2.ps1 'pacman -Sy --noconfirm \
          mingw-w64-ucrt-x86_64-toolchain \
          mingw-w64-ucrt-x86_64-python \
          mingw-w64-ucrt-x86_64-python-pip \
          mingw-w64-ucrt-x86_64-meson \
          mingw-w64-ucrt-x86_64-ninja \
          mingw-w64-ucrt-x86_64-pkg-config \
          {% if cookiecutter.include_python_extension != 'false' -%}
          mingw-w64-ucrt-x86_64-meson-python \
          mingw-w64-ucrt-x86_64-python-build \
          {%- endif %}
          {% if cookiecutter.include_python_extension == 'true_with_numpy' -%}
          mingw-w64-ucrt-x86_64-python-numpy \
          {%- endif %}
          {% if cookiecutter.include_doxygen -%}
          mingw-w64-ucrt-x86_64-doxygen \
          mingw-w64-ucrt-x86_64-graphviz \
          {%- endif %}
          mingw-w64-ucrt-x86_64-curl \
          {% if cookiecutter.min_boost_version != 'na' -%}
          mingw-w64-ucrt-x86_64-dlfcn \
          mingw-w64-ucrt-x86_64-zlib \
          mingw-w64-ucrt-x86_64-bzip2 \
          mingw-w64-ucrt-x86_64-zstd \
          mingw-w64-ucrt-x86_64-xz \
          mingw-w64-ucrt-x86_64-icu \
          mingw-w64-ucrt-x86_64-openssl
          {%- endif %}
          '
        {% if cookiecutter.min_boost_version != 'na' -%}
        # DO NOT INSTALL BOOST HERE - Set version for installation in subsequent steps
        #
        # NOTE: The pacman packages installed above (after curl) are required for building boost.
        $BOOST_VER="{{ cookiecutter.min_boost_version }}"
        Add-Content $Env:GITHUB_ENV "BOOST_VER=$BOOST_VER"
        {%- endif %}
        # Extract GCC version
        $GCC_VER = (.\msys2.ps1 'gcc -dumpfullversion | xargs').Trim()
        Add-Content $Env:GITHUB_ENV "GCC_VER=$GCC_VER"
    {% if cookiecutter.min_boost_version != 'na' -%}
    # NOTE: You may be able to download boost via pacman in the block above and avoid building from scratch in the steps below. Ensure
    #       that the version of boost provided by pacman is >= min version you're expecting ({{ cookiecutter.min_boost_version }}).
    #
    #       As of writing, the version of boost it offers doesn't support numpy2 and so this job fails - it may be that it gets upgraded
    #       to a proper version.
    - name: Cache Boost
      id: boost-cache
      uses: actions/cache@v4
      with:
        path: ~/boost-gcc
        key: {{ "boost-${{ env.BOOST_VER }}-msys2-gcc${{ env.GCC_VER }}-ucrt-${{ runner.os }}-${{ runner.arch }}" }}
    - name: Build Boost if cache miss
      if: steps.boost-cache.outputs.cache-hit != 'true'
      shell: pwsh
      run: |
        # Force non-zero exit codes to stop task (similar to how linux/mac runners work).
        $PSNativeCommandUseErrorActionPreference = $true
        $ErrorActionPreference = 'Stop'
        # Download boost and build.
        #
        # NOTE: The b2 arguments used below have the following meaning...
        #
        #        * -j"$(nproc)"" utilizes all cores, to keep the build fast.
        #        * -variant=release builds a release version of boost (as opposed to a debug version).
        #          (see https://stackoverflow.com/q/73237306)
        #        * -threading-multi builds a thread-aware version of boost. Note that thread-aware does not mean thread-safe: Thread-safe
        #          means that access to the same object from multiple threads is safe, while thread-aware means that boost objects work
        #          fine when used solely within a single thread of a multithreaded application.
        #          (https://stackoverflow.com/a/20991533)
        #        * -address-model=64 prevents 32-bit builds: According to o3 if you don't have it there, the build process happens for both
        #           32-bit and 64-bit platforms. For the 32-bite build, there's no 32-bit version of Python to compile against, and so the
        #           build fails. As such, this targets only 64-bit.
        #
        # NOTE: o3 used the following arguments, but I've removed them because either boost's buildsystem already does this, or they're
        #       not required, or they might end up breaking things.
        #
        #        * -cxxflags="-march=native -flto -pipe" -linkflags="-march=native -flto"
        #          * is machine architecture implicitly set to native already?
        #          * no need for link-time optimizations. If it's not being enabled implicitly by boost's build system, I'd rather not
        #            enable it. Even if everything turns out fine, the extra build timecost of enabling it may not be worth the marginal
        #            benefits.
        #          * leave whether to use pipe vs temp files to boost's build system.
        #
        # NOTE: $USERPROFILE points to the Windows user's home directory. That is, the path in cache task directly above this one
        #       (~/boost-gcc) and the path in the commands below ($USERPROFILE/boost-gcc) point to the same directory.
        #
        # NOTE: bootstrap.sh gets fed the --prefix path in Windows style rather than Posix style because b2 is a Windows executable and
        #       expects a Windows path. If you pass in a Posix path, it gets translated incorrectly (e.g. /c/Users/runneradmin/boost-gcc
        #       gets rewritten to \c\Users\runneradmin\boost-gcc, which the kernel resolves as C:\c\Users\runneradmin\boost-gcc).
        #
        # WARNING: o3 claims --with-python-root=/ucrt64 because Boost doesn't know where to find Python includes (e.g.,
        #          /ucrt64/include/python3.12). Apparently bootstrap.sh finds /ucrt64/bin/python*, launches it to run the command
        #          "sysconfig.get_python_inc()", and gets the correct include dir back.
        .\msys2.ps1 '
            export BOOST_VER={{ "${{ env.BOOST_VER }}" }} && \
            export BOOST_ROOT=""$(cygpath -u ""$USERPROFILE"")/boost-gcc""
            export BOOST_ROOT_WINDOWS_STYLE=""$(cygpath -m ""$USERPROFILE"")/boost-gcc""
            curl -L ""https://archives.boost.io/release/${BOOST_VER}/source/boost_${BOOST_VER//./_}.tar.bz2"" | tar -xj -C ""/tmp"" && \
            cd /tmp/boost_* && \
            ./bootstrap.sh --with-toolset=gcc --with-python-root=/ucrt64 --prefix=$BOOST_ROOT_WINDOWS_STYLE && \
            ./b2 \
              -j""$(nproc)"" \
              address-model=64 \
              variant=release link=static,shared threading=multi \
              linkflags=""-ldl"" \
              install'
    - name: Prime for building
      shell: pwsh
      run: |
        # Prime env for compiled boost.
        .\msys2.ps1 '
            BOOST_ROOT=""$(cygpath -u ""$USERPROFILE"")/boost-gcc"" && \
            echo ""export BOOST_ROOT=$BOOST_ROOT"" >> ~/.bash_profile && \
            echo ""export CPATH=$BOOST_ROOT/include:${CPATH:-}"" >> ~/.bash_profile && \
            echo ""export LIBRARY_PATH=$BOOST_ROOT/lib:${LIBRARY_PATH:-}"" >> ~/.bash_profile && \
            echo ""export LD_LIBRARY_PATH=$BOOST_ROOT/lib:${LD_LIBRARY_PATH:-}"" >> ~/.bash_profile'
        .\msys2.ps1 'cat ~/.bash_profile'
        .\msys2.ps1 'env'
        .\msys2.ps1 'echo $BOOST_ROOT'
        .\msys2.ps1 'ls -al $BOOST_ROOT'
    {%- endif %}